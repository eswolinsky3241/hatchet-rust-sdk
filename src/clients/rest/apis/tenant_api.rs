/*
 * Hatchet API
 *
 * The Hatchet API
 *
 * The version of the OpenAPI document: 1.0.0
 *
 * Generated by: https://openapi-generator.tech
 */

use super::{ContentType, Error, configuration};
use crate::clients::rest::{apis::ResponseContent, models};
use reqwest;
use serde::{Deserialize, Serialize, de::Error as _};

/// struct for typed errors of method [`alert_email_group_create`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum AlertEmailGroupCreateError {
    Status400(models::V1TaskGet400Response),
    Status403(models::V1TaskGet400ResponseErrorsInner),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`alert_email_group_delete`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum AlertEmailGroupDeleteError {
    Status400(models::V1TaskGet400Response),
    Status403(models::V1TaskGet400ResponseErrorsInner),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`alert_email_group_list`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum AlertEmailGroupListError {
    Status400(models::V1TaskGet400Response),
    Status403(models::V1TaskGet400ResponseErrorsInner),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`alert_email_group_update`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum AlertEmailGroupUpdateError {
    Status400(models::V1TaskGet400Response),
    Status403(models::V1TaskGet400ResponseErrorsInner),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`tenant_alerting_settings_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum TenantAlertingSettingsGetError {
    Status400(models::V1TaskGet400Response),
    Status403(models::V1TaskGet400ResponseErrorsInner),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`tenant_create`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum TenantCreateError {
    Status400(models::V1TaskGet400Response),
    Status403(models::V1TaskGet400ResponseErrorsInner),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`tenant_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum TenantGetError {
    Status400(models::V1TaskGet400Response),
    Status403(models::V1TaskGet400ResponseErrorsInner),
    Status404(models::V1TaskGet400Response),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`tenant_get_prometheus_metrics`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum TenantGetPrometheusMetricsError {
    Status400(models::V1TaskGet400Response),
    Status403(models::V1TaskGet400Response),
    Status404(models::V1TaskGet400Response),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`tenant_get_step_run_queue_metrics`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum TenantGetStepRunQueueMetricsError {
    Status400(models::V1TaskGet400Response),
    Status403(models::V1TaskGet400Response),
    Status404(models::V1TaskGet400Response),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`tenant_invite_accept`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum TenantInviteAcceptError {
    Status400(models::V1TaskGet400Response),
    Status403(models::V1TaskGet400ResponseErrorsInner),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`tenant_invite_create`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum TenantInviteCreateError {
    Status400(models::V1TaskGet400Response),
    Status403(models::V1TaskGet400ResponseErrorsInner),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`tenant_invite_list`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum TenantInviteListError {
    Status400(models::V1TaskGet400Response),
    Status403(models::V1TaskGet400ResponseErrorsInner),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`tenant_invite_reject`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum TenantInviteRejectError {
    Status400(models::V1TaskGet400Response),
    Status403(models::V1TaskGet400ResponseErrorsInner),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`tenant_member_delete`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum TenantMemberDeleteError {
    Status400(models::V1TaskGet400Response),
    Status403(models::V1TaskGet400Response),
    Status404(models::V1TaskGet400Response),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`tenant_member_list`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum TenantMemberListError {
    Status400(models::V1TaskGet400Response),
    Status403(models::V1TaskGet400ResponseErrorsInner),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`tenant_member_update`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum TenantMemberUpdateError {
    Status400(models::V1TaskGet400Response),
    Status403(models::V1TaskGet400Response),
    Status404(models::V1TaskGet400Response),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`tenant_resource_policy_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum TenantResourcePolicyGetError {
    Status400(models::V1TaskGet400Response),
    Status403(models::V1TaskGet400ResponseErrorsInner),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`tenant_update`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum TenantUpdateError {
    Status400(models::V1TaskGet400Response),
    Status403(models::V1TaskGet400ResponseErrorsInner),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`user_list_tenant_invites`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum UserListTenantInvitesError {
    Status400(models::V1TaskGet400Response),
    Status403(models::V1TaskGet400Response),
    UnknownValue(serde_json::Value),
}

/// Creates a new tenant alert email group
pub async fn alert_email_group_create(
    configuration: &configuration::Configuration,
    tenant: &str,
    alert_email_group_create_request: models::AlertEmailGroupCreateRequest,
) -> Result<models::AlertEmailGroupList200ResponseRowsInner, Error<AlertEmailGroupCreateError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_tenant = tenant;
    let p_alert_email_group_create_request = alert_email_group_create_request;

    let uri_str = format!(
        "{}/api/v1/tenants/{tenant}/alerting-email-groups",
        configuration.base_path,
        tenant = crate::clients::rest::apis::urlencode(p_tenant)
    );
    let mut req_builder = configuration
        .client
        .request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    req_builder = req_builder.json(&p_alert_email_group_create_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => {
                return Err(Error::from(serde_json::Error::custom(
                    "Received `text/plain` content type response that cannot be converted to `models::AlertEmailGroupList200ResponseRowsInner`",
                )));
            }
            ContentType::Unsupported(unknown_type) => {
                return Err(Error::from(serde_json::Error::custom(format!(
                    "Received `{unknown_type}` content type response that cannot be converted to `models::AlertEmailGroupList200ResponseRowsInner`"
                ))));
            }
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<AlertEmailGroupCreateError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// Deletes a tenant alert email group
pub async fn alert_email_group_delete(
    configuration: &configuration::Configuration,
    alert_email_group: &str,
) -> Result<(), Error<AlertEmailGroupDeleteError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_alert_email_group = alert_email_group;

    let uri_str = format!(
        "{}/api/v1/alerting-email-groups/{alert_email_group}",
        configuration.base_path,
        alert_email_group = crate::clients::rest::apis::urlencode(p_alert_email_group)
    );
    let mut req_builder = configuration
        .client
        .request(reqwest::Method::DELETE, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        Ok(())
    } else {
        let content = resp.text().await?;
        let entity: Option<AlertEmailGroupDeleteError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// Gets a list of tenant alert email groups
pub async fn alert_email_group_list(
    configuration: &configuration::Configuration,
    tenant: &str,
) -> Result<models::AlertEmailGroupList200Response, Error<AlertEmailGroupListError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_tenant = tenant;

    let uri_str = format!(
        "{}/api/v1/tenants/{tenant}/alerting-email-groups",
        configuration.base_path,
        tenant = crate::clients::rest::apis::urlencode(p_tenant)
    );
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => {
                return Err(Error::from(serde_json::Error::custom(
                    "Received `text/plain` content type response that cannot be converted to `models::AlertEmailGroupList200Response`",
                )));
            }
            ContentType::Unsupported(unknown_type) => {
                return Err(Error::from(serde_json::Error::custom(format!(
                    "Received `{unknown_type}` content type response that cannot be converted to `models::AlertEmailGroupList200Response`"
                ))));
            }
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<AlertEmailGroupListError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// Updates a tenant alert email group
pub async fn alert_email_group_update(
    configuration: &configuration::Configuration,
    alert_email_group: &str,
    alert_email_group_create_request: models::AlertEmailGroupCreateRequest,
) -> Result<models::AlertEmailGroupList200ResponseRowsInner, Error<AlertEmailGroupUpdateError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_alert_email_group = alert_email_group;
    let p_alert_email_group_create_request = alert_email_group_create_request;

    let uri_str = format!(
        "{}/api/v1/alerting-email-groups/{alert_email_group}",
        configuration.base_path,
        alert_email_group = crate::clients::rest::apis::urlencode(p_alert_email_group)
    );
    let mut req_builder = configuration
        .client
        .request(reqwest::Method::PATCH, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    req_builder = req_builder.json(&p_alert_email_group_create_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => {
                return Err(Error::from(serde_json::Error::custom(
                    "Received `text/plain` content type response that cannot be converted to `models::AlertEmailGroupList200ResponseRowsInner`",
                )));
            }
            ContentType::Unsupported(unknown_type) => {
                return Err(Error::from(serde_json::Error::custom(format!(
                    "Received `{unknown_type}` content type response that cannot be converted to `models::AlertEmailGroupList200ResponseRowsInner`"
                ))));
            }
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<AlertEmailGroupUpdateError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// Gets the alerting settings for a tenant
pub async fn tenant_alerting_settings_get(
    configuration: &configuration::Configuration,
    tenant: &str,
) -> Result<models::TenantAlertingSettingsGet200Response, Error<TenantAlertingSettingsGetError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_tenant = tenant;

    let uri_str = format!(
        "{}/api/v1/tenants/{tenant}/alerting/settings",
        configuration.base_path,
        tenant = crate::clients::rest::apis::urlencode(p_tenant)
    );
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => {
                return Err(Error::from(serde_json::Error::custom(
                    "Received `text/plain` content type response that cannot be converted to `models::TenantAlertingSettingsGet200Response`",
                )));
            }
            ContentType::Unsupported(unknown_type) => {
                return Err(Error::from(serde_json::Error::custom(format!(
                    "Received `{unknown_type}` content type response that cannot be converted to `models::TenantAlertingSettingsGet200Response`"
                ))));
            }
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<TenantAlertingSettingsGetError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// Creates a new tenant
pub async fn tenant_create(
    configuration: &configuration::Configuration,
    tenant_create_request: models::TenantCreateRequest,
) -> Result<models::V1EventList200ResponseRowsInnerTenant, Error<TenantCreateError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_tenant_create_request = tenant_create_request;

    let uri_str = format!("{}/api/v1/tenants", configuration.base_path);
    let mut req_builder = configuration
        .client
        .request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    req_builder = req_builder.json(&p_tenant_create_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => {
                return Err(Error::from(serde_json::Error::custom(
                    "Received `text/plain` content type response that cannot be converted to `models::V1EventList200ResponseRowsInnerTenant`",
                )));
            }
            ContentType::Unsupported(unknown_type) => {
                return Err(Error::from(serde_json::Error::custom(format!(
                    "Received `{unknown_type}` content type response that cannot be converted to `models::V1EventList200ResponseRowsInnerTenant`"
                ))));
            }
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<TenantCreateError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// Get the details of a tenant
pub async fn tenant_get(
    configuration: &configuration::Configuration,
    tenant: &str,
) -> Result<models::V1EventList200ResponseRowsInnerTenant, Error<TenantGetError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_tenant = tenant;

    let uri_str = format!(
        "{}/api/v1/tenants/{tenant}",
        configuration.base_path,
        tenant = crate::clients::rest::apis::urlencode(p_tenant)
    );
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => {
                return Err(Error::from(serde_json::Error::custom(
                    "Received `text/plain` content type response that cannot be converted to `models::V1EventList200ResponseRowsInnerTenant`",
                )));
            }
            ContentType::Unsupported(unknown_type) => {
                return Err(Error::from(serde_json::Error::custom(format!(
                    "Received `{unknown_type}` content type response that cannot be converted to `models::V1EventList200ResponseRowsInnerTenant`"
                ))));
            }
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<TenantGetError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// Get the prometheus metrics for the tenant
pub async fn tenant_get_prometheus_metrics(
    configuration: &configuration::Configuration,
    tenant: &str,
) -> Result<String, Error<TenantGetPrometheusMetricsError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_tenant = tenant;

    let uri_str = format!(
        "{}/api/v1/tenants/{tenant}/prometheus-metrics",
        configuration.base_path,
        tenant = crate::clients::rest::apis::urlencode(p_tenant)
    );
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Ok(content),
            ContentType::Unsupported(unknown_type) => {
                return Err(Error::from(serde_json::Error::custom(format!(
                    "Received `{unknown_type}` content type response that cannot be converted to `String`"
                ))));
            }
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<TenantGetPrometheusMetricsError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// Get the queue metrics for the tenant
pub async fn tenant_get_step_run_queue_metrics(
    configuration: &configuration::Configuration,
    tenant: &str,
) -> Result<models::TenantGetStepRunQueueMetrics200Response, Error<TenantGetStepRunQueueMetricsError>>
{
    // add a prefix to parameters to efficiently prevent name collisions
    let p_tenant = tenant;

    let uri_str = format!(
        "{}/api/v1/tenants/{tenant}/step-run-queue-metrics",
        configuration.base_path,
        tenant = crate::clients::rest::apis::urlencode(p_tenant)
    );
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => {
                return Err(Error::from(serde_json::Error::custom(
                    "Received `text/plain` content type response that cannot be converted to `models::TenantGetStepRunQueueMetrics200Response`",
                )));
            }
            ContentType::Unsupported(unknown_type) => {
                return Err(Error::from(serde_json::Error::custom(format!(
                    "Received `{unknown_type}` content type response that cannot be converted to `models::TenantGetStepRunQueueMetrics200Response`"
                ))));
            }
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<TenantGetStepRunQueueMetricsError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// Accepts a tenant invite
pub async fn tenant_invite_accept(
    configuration: &configuration::Configuration,
    tenant_invite_accept_request: Option<models::TenantInviteAcceptRequest>,
) -> Result<(), Error<TenantInviteAcceptError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_tenant_invite_accept_request = tenant_invite_accept_request;

    let uri_str = format!("{}/api/v1/users/invites/accept", configuration.base_path);
    let mut req_builder = configuration
        .client
        .request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    req_builder = req_builder.json(&p_tenant_invite_accept_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        Ok(())
    } else {
        let content = resp.text().await?;
        let entity: Option<TenantInviteAcceptError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// Creates a new tenant invite
pub async fn tenant_invite_create(
    configuration: &configuration::Configuration,
    tenant: &str,
    tenant_invite_create_request: models::TenantInviteCreateRequest,
) -> Result<models::UserListTenantInvites200ResponseRowsInner, Error<TenantInviteCreateError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_tenant = tenant;
    let p_tenant_invite_create_request = tenant_invite_create_request;

    let uri_str = format!(
        "{}/api/v1/tenants/{tenant}/invites",
        configuration.base_path,
        tenant = crate::clients::rest::apis::urlencode(p_tenant)
    );
    let mut req_builder = configuration
        .client
        .request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    req_builder = req_builder.json(&p_tenant_invite_create_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => {
                return Err(Error::from(serde_json::Error::custom(
                    "Received `text/plain` content type response that cannot be converted to `models::UserListTenantInvites200ResponseRowsInner`",
                )));
            }
            ContentType::Unsupported(unknown_type) => {
                return Err(Error::from(serde_json::Error::custom(format!(
                    "Received `{unknown_type}` content type response that cannot be converted to `models::UserListTenantInvites200ResponseRowsInner`"
                ))));
            }
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<TenantInviteCreateError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// Gets a list of tenant invites
pub async fn tenant_invite_list(
    configuration: &configuration::Configuration,
    tenant: &str,
) -> Result<models::UserListTenantInvites200Response, Error<TenantInviteListError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_tenant = tenant;

    let uri_str = format!(
        "{}/api/v1/tenants/{tenant}/invites",
        configuration.base_path,
        tenant = crate::clients::rest::apis::urlencode(p_tenant)
    );
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => {
                return Err(Error::from(serde_json::Error::custom(
                    "Received `text/plain` content type response that cannot be converted to `models::UserListTenantInvites200Response`",
                )));
            }
            ContentType::Unsupported(unknown_type) => {
                return Err(Error::from(serde_json::Error::custom(format!(
                    "Received `{unknown_type}` content type response that cannot be converted to `models::UserListTenantInvites200Response`"
                ))));
            }
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<TenantInviteListError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// Rejects a tenant invite
pub async fn tenant_invite_reject(
    configuration: &configuration::Configuration,
    tenant_invite_accept_request: Option<models::TenantInviteAcceptRequest>,
) -> Result<(), Error<TenantInviteRejectError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_tenant_invite_accept_request = tenant_invite_accept_request;

    let uri_str = format!("{}/api/v1/users/invites/reject", configuration.base_path);
    let mut req_builder = configuration
        .client
        .request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    req_builder = req_builder.json(&p_tenant_invite_accept_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        Ok(())
    } else {
        let content = resp.text().await?;
        let entity: Option<TenantInviteRejectError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// Delete a member from a tenant
pub async fn tenant_member_delete(
    configuration: &configuration::Configuration,
    tenant: &str,
    member: &str,
) -> Result<models::TenantMembershipsList200ResponseRowsInner, Error<TenantMemberDeleteError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_tenant = tenant;
    let p_member = member;

    let uri_str = format!(
        "{}/api/v1/tenants/{tenant}/members/{member}",
        configuration.base_path,
        tenant = crate::clients::rest::apis::urlencode(p_tenant),
        member = crate::clients::rest::apis::urlencode(p_member)
    );
    let mut req_builder = configuration
        .client
        .request(reqwest::Method::DELETE, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => {
                return Err(Error::from(serde_json::Error::custom(
                    "Received `text/plain` content type response that cannot be converted to `models::TenantMembershipsList200ResponseRowsInner`",
                )));
            }
            ContentType::Unsupported(unknown_type) => {
                return Err(Error::from(serde_json::Error::custom(format!(
                    "Received `{unknown_type}` content type response that cannot be converted to `models::TenantMembershipsList200ResponseRowsInner`"
                ))));
            }
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<TenantMemberDeleteError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// Gets a list of tenant members
pub async fn tenant_member_list(
    configuration: &configuration::Configuration,
    tenant: &str,
) -> Result<models::TenantMembershipsList200Response, Error<TenantMemberListError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_tenant = tenant;

    let uri_str = format!(
        "{}/api/v1/tenants/{tenant}/members",
        configuration.base_path,
        tenant = crate::clients::rest::apis::urlencode(p_tenant)
    );
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => {
                return Err(Error::from(serde_json::Error::custom(
                    "Received `text/plain` content type response that cannot be converted to `models::TenantMembershipsList200Response`",
                )));
            }
            ContentType::Unsupported(unknown_type) => {
                return Err(Error::from(serde_json::Error::custom(format!(
                    "Received `{unknown_type}` content type response that cannot be converted to `models::TenantMembershipsList200Response`"
                ))));
            }
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<TenantMemberListError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// Update a tenant member
pub async fn tenant_member_update(
    configuration: &configuration::Configuration,
    tenant: &str,
    member: &str,
    tenant_invite_update_request: models::TenantInviteUpdateRequest,
) -> Result<models::TenantMembershipsList200ResponseRowsInner, Error<TenantMemberUpdateError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_tenant = tenant;
    let p_member = member;
    let p_tenant_invite_update_request = tenant_invite_update_request;

    let uri_str = format!(
        "{}/api/v1/tenants/{tenant}/members/{member}",
        configuration.base_path,
        tenant = crate::clients::rest::apis::urlencode(p_tenant),
        member = crate::clients::rest::apis::urlencode(p_member)
    );
    let mut req_builder = configuration
        .client
        .request(reqwest::Method::PATCH, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    req_builder = req_builder.json(&p_tenant_invite_update_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => {
                return Err(Error::from(serde_json::Error::custom(
                    "Received `text/plain` content type response that cannot be converted to `models::TenantMembershipsList200ResponseRowsInner`",
                )));
            }
            ContentType::Unsupported(unknown_type) => {
                return Err(Error::from(serde_json::Error::custom(format!(
                    "Received `{unknown_type}` content type response that cannot be converted to `models::TenantMembershipsList200ResponseRowsInner`"
                ))));
            }
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<TenantMemberUpdateError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// Gets the resource policy for a tenant
pub async fn tenant_resource_policy_get(
    configuration: &configuration::Configuration,
    tenant: &str,
) -> Result<models::TenantResourcePolicyGet200Response, Error<TenantResourcePolicyGetError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_tenant = tenant;

    let uri_str = format!(
        "{}/api/v1/tenants/{tenant}/resource-policy",
        configuration.base_path,
        tenant = crate::clients::rest::apis::urlencode(p_tenant)
    );
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => {
                return Err(Error::from(serde_json::Error::custom(
                    "Received `text/plain` content type response that cannot be converted to `models::TenantResourcePolicyGet200Response`",
                )));
            }
            ContentType::Unsupported(unknown_type) => {
                return Err(Error::from(serde_json::Error::custom(format!(
                    "Received `{unknown_type}` content type response that cannot be converted to `models::TenantResourcePolicyGet200Response`"
                ))));
            }
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<TenantResourcePolicyGetError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// Update an existing tenant
pub async fn tenant_update(
    configuration: &configuration::Configuration,
    tenant: &str,
    tenant_update_request: models::TenantUpdateRequest,
) -> Result<models::V1EventList200ResponseRowsInnerTenant, Error<TenantUpdateError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_tenant = tenant;
    let p_tenant_update_request = tenant_update_request;

    let uri_str = format!(
        "{}/api/v1/tenants/{tenant}",
        configuration.base_path,
        tenant = crate::clients::rest::apis::urlencode(p_tenant)
    );
    let mut req_builder = configuration
        .client
        .request(reqwest::Method::PATCH, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    req_builder = req_builder.json(&p_tenant_update_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => {
                return Err(Error::from(serde_json::Error::custom(
                    "Received `text/plain` content type response that cannot be converted to `models::V1EventList200ResponseRowsInnerTenant`",
                )));
            }
            ContentType::Unsupported(unknown_type) => {
                return Err(Error::from(serde_json::Error::custom(format!(
                    "Received `{unknown_type}` content type response that cannot be converted to `models::V1EventList200ResponseRowsInnerTenant`"
                ))));
            }
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<TenantUpdateError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// Lists all tenant invites for the current user
pub async fn user_list_tenant_invites(
    configuration: &configuration::Configuration,
) -> Result<models::UserListTenantInvites200Response, Error<UserListTenantInvitesError>> {
    let uri_str = format!("{}/api/v1/users/invites", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => {
                return Err(Error::from(serde_json::Error::custom(
                    "Received `text/plain` content type response that cannot be converted to `models::UserListTenantInvites200Response`",
                )));
            }
            ContentType::Unsupported(unknown_type) => {
                return Err(Error::from(serde_json::Error::custom(format!(
                    "Received `{unknown_type}` content type response that cannot be converted to `models::UserListTenantInvites200Response`"
                ))));
            }
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<UserListTenantInvitesError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}
