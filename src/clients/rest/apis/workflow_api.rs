/*
 * Hatchet API
 *
 * The Hatchet API
 *
 * The version of the OpenAPI document: 1.0.0
 * 
 * Generated by: https://openapi-generator.tech
 */


use reqwest;
use serde::{Deserialize, Serialize, de::Error as _};
use crate::clients::rest::{apis::ResponseContent, models};
use super::{Error, configuration, ContentType};


/// struct for typed errors of method [`cron_workflow_list`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CronWorkflowListError {
    Status400(models::V1TaskGet400Response),
    Status403(models::V1TaskGet400Response),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`tenant_get_queue_metrics`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum TenantGetQueueMetricsError {
    Status400(models::V1TaskGet400Response),
    Status403(models::V1TaskGet400Response),
    Status404(models::V1TaskGet400Response),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`workflow_cron_delete`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum WorkflowCronDeleteError {
    Status400(models::V1TaskGet400Response),
    Status403(models::V1TaskGet400ResponseErrorsInner),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`workflow_cron_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum WorkflowCronGetError {
    Status400(models::V1TaskGet400Response),
    Status403(models::V1TaskGet400Response),
    Status404(models::V1TaskGet400Response),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`workflow_delete`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum WorkflowDeleteError {
    Status400(models::V1TaskGet400Response),
    Status403(models::V1TaskGet400Response),
    Status404(models::V1TaskGet400Response),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`workflow_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum WorkflowGetError {
    Status404(models::V1TaskGet400Response),
    Status400(models::V1TaskGet400Response),
    Status403(models::V1TaskGet400Response),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`workflow_get_metrics`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum WorkflowGetMetricsError {
    Status400(models::V1TaskGet400Response),
    Status403(models::V1TaskGet400Response),
    Status404(models::V1TaskGet400Response),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`workflow_get_workers_count`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum WorkflowGetWorkersCountError {
    Status400(models::V1TaskGet400Response),
    Status403(models::V1TaskGet400Response),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`workflow_list`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum WorkflowListError {
    Status400(models::V1TaskGet400Response),
    Status403(models::V1TaskGet400Response),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`workflow_run_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum WorkflowRunGetError {
    Status400(models::V1TaskGet400Response),
    Status403(models::V1TaskGet400Response),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`workflow_run_get_metrics`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum WorkflowRunGetMetricsError {
    Status400(models::V1TaskGet400Response),
    Status403(models::V1TaskGet400Response),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`workflow_run_get_shape`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum WorkflowRunGetShapeError {
    Status400(models::V1TaskGet400Response),
    Status403(models::V1TaskGet400Response),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`workflow_run_list`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum WorkflowRunListError {
    Status400(models::V1TaskGet400Response),
    Status403(models::V1TaskGet400Response),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`workflow_scheduled_delete`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum WorkflowScheduledDeleteError {
    Status400(models::V1TaskGet400Response),
    Status403(models::V1TaskGet400ResponseErrorsInner),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`workflow_scheduled_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum WorkflowScheduledGetError {
    Status400(models::V1TaskGet400Response),
    Status403(models::V1TaskGet400Response),
    Status404(models::V1TaskGet400Response),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`workflow_scheduled_list`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum WorkflowScheduledListError {
    Status400(models::V1TaskGet400Response),
    Status403(models::V1TaskGet400Response),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`workflow_update`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum WorkflowUpdateError {
    Status400(models::V1TaskGet400Response),
    Status403(models::V1TaskGet400Response),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`workflow_version_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum WorkflowVersionGetError {
    Status400(models::V1TaskGet400Response),
    Status403(models::V1TaskGet400Response),
    Status404(models::V1TaskGet400Response),
    UnknownValue(serde_json::Value),
}


/// Get all cron job workflow triggers for a tenant
pub async fn cron_workflow_list(configuration: &configuration::Configuration, tenant: &str, offset: Option<i64>, limit: Option<i64>, workflow_id: Option<&str>, workflow_name: Option<&str>, cron_name: Option<&str>, additional_metadata: Option<Vec<String>>, order_by_field: Option<&str>, order_by_direction: Option<&str>) -> Result<models::CronWorkflowList200Response, Error<CronWorkflowListError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_tenant = tenant;
    let p_offset = offset;
    let p_limit = limit;
    let p_workflow_id = workflow_id;
    let p_workflow_name = workflow_name;
    let p_cron_name = cron_name;
    let p_additional_metadata = additional_metadata;
    let p_order_by_field = order_by_field;
    let p_order_by_direction = order_by_direction;

    let uri_str = format!("{}/api/v1/tenants/{tenant}/workflows/crons", configuration.base_path, tenant=crate::clients::rest::apis::urlencode(p_tenant));
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = p_offset {
        req_builder = req_builder.query(&[("offset", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_limit {
        req_builder = req_builder.query(&[("limit", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_workflow_id {
        req_builder = req_builder.query(&[("workflowId", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_workflow_name {
        req_builder = req_builder.query(&[("workflowName", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_cron_name {
        req_builder = req_builder.query(&[("cronName", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_additional_metadata {
        req_builder = match "multi" {
            "multi" => req_builder.query(&param_value.into_iter().map(|p| ("additionalMetadata".to_owned(), p.to_string())).collect::<Vec<(std::string::String, std::string::String)>>()),
            _ => req_builder.query(&[("additionalMetadata", &param_value.into_iter().map(|p| p.to_string()).collect::<Vec<String>>().join(",").to_string())]),
        };
    }
    if let Some(ref param_value) = p_order_by_field {
        req_builder = req_builder.query(&[("orderByField", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_order_by_direction {
        req_builder = req_builder.query(&[("orderByDirection", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::CronWorkflowList200Response`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::CronWorkflowList200Response`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<CronWorkflowListError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Get the queue metrics for the tenant
pub async fn tenant_get_queue_metrics(configuration: &configuration::Configuration, tenant: &str, workflows: Option<Vec<String>>, additional_metadata: Option<Vec<String>>) -> Result<models::TenantGetQueueMetrics200Response, Error<TenantGetQueueMetricsError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_tenant = tenant;
    let p_workflows = workflows;
    let p_additional_metadata = additional_metadata;

    let uri_str = format!("{}/api/v1/tenants/{tenant}/queue-metrics", configuration.base_path, tenant=crate::clients::rest::apis::urlencode(p_tenant));
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = p_workflows {
        req_builder = match "multi" {
            "multi" => req_builder.query(&param_value.into_iter().map(|p| ("workflows".to_owned(), p.to_string())).collect::<Vec<(std::string::String, std::string::String)>>()),
            _ => req_builder.query(&[("workflows", &param_value.into_iter().map(|p| p.to_string()).collect::<Vec<String>>().join(",").to_string())]),
        };
    }
    if let Some(ref param_value) = p_additional_metadata {
        req_builder = match "multi" {
            "multi" => req_builder.query(&param_value.into_iter().map(|p| ("additionalMetadata".to_owned(), p.to_string())).collect::<Vec<(std::string::String, std::string::String)>>()),
            _ => req_builder.query(&[("additionalMetadata", &param_value.into_iter().map(|p| p.to_string()).collect::<Vec<String>>().join(",").to_string())]),
        };
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::TenantGetQueueMetrics200Response`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::TenantGetQueueMetrics200Response`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<TenantGetQueueMetricsError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Delete a cron job workflow run for a tenant
pub async fn workflow_cron_delete(configuration: &configuration::Configuration, tenant: &str, cron_workflow: &str) -> Result<(), Error<WorkflowCronDeleteError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_tenant = tenant;
    let p_cron_workflow = cron_workflow;

    let uri_str = format!("{}/api/v1/tenants/{tenant}/workflows/crons/{cron_workflow}", configuration.base_path, tenant=crate::clients::rest::apis::urlencode(p_tenant), cron_workflow=crate::clients::rest::apis::urlencode(p_cron_workflow));
    let mut req_builder = configuration.client.request(reqwest::Method::DELETE, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        Ok(())
    } else {
        let content = resp.text().await?;
        let entity: Option<WorkflowCronDeleteError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Get a cron job workflow run for a tenant
pub async fn workflow_cron_get(configuration: &configuration::Configuration, tenant: &str, cron_workflow: &str) -> Result<models::CronWorkflowTriggerCreate200Response, Error<WorkflowCronGetError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_tenant = tenant;
    let p_cron_workflow = cron_workflow;

    let uri_str = format!("{}/api/v1/tenants/{tenant}/workflows/crons/{cron_workflow}", configuration.base_path, tenant=crate::clients::rest::apis::urlencode(p_tenant), cron_workflow=crate::clients::rest::apis::urlencode(p_cron_workflow));
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::CronWorkflowTriggerCreate200Response`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::CronWorkflowTriggerCreate200Response`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<WorkflowCronGetError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Delete a workflow for a tenant
pub async fn workflow_delete(configuration: &configuration::Configuration, workflow: &str) -> Result<(), Error<WorkflowDeleteError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_workflow = workflow;

    let uri_str = format!("{}/api/v1/workflows/{workflow}", configuration.base_path, workflow=crate::clients::rest::apis::urlencode(p_workflow));
    let mut req_builder = configuration.client.request(reqwest::Method::DELETE, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        Ok(())
    } else {
        let content = resp.text().await?;
        let entity: Option<WorkflowDeleteError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Get a workflow for a tenant
pub async fn workflow_get(configuration: &configuration::Configuration, workflow: &str) -> Result<models::WorkflowList200ResponseRowsInner, Error<WorkflowGetError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_workflow = workflow;

    let uri_str = format!("{}/api/v1/workflows/{workflow}", configuration.base_path, workflow=crate::clients::rest::apis::urlencode(p_workflow));
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::WorkflowList200ResponseRowsInner`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::WorkflowList200ResponseRowsInner`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<WorkflowGetError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Get the metrics for a workflow version
pub async fn workflow_get_metrics(configuration: &configuration::Configuration, workflow: &str, status: Option<&str>, group_key: Option<&str>) -> Result<models::WorkflowGetMetrics200Response, Error<WorkflowGetMetricsError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_workflow = workflow;
    let p_status = status;
    let p_group_key = group_key;

    let uri_str = format!("{}/api/v1/workflows/{workflow}/metrics", configuration.base_path, workflow=crate::clients::rest::apis::urlencode(p_workflow));
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = p_status {
        req_builder = req_builder.query(&[("status", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_group_key {
        req_builder = req_builder.query(&[("groupKey", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::WorkflowGetMetrics200Response`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::WorkflowGetMetrics200Response`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<WorkflowGetMetricsError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Get a count of the workers available for workflow
pub async fn workflow_get_workers_count(configuration: &configuration::Configuration, tenant: &str, workflow: &str) -> Result<models::WorkflowGetWorkersCount200Response, Error<WorkflowGetWorkersCountError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_tenant = tenant;
    let p_workflow = workflow;

    let uri_str = format!("{}/api/v1/tenants/{tenant}/workflows/{workflow}/worker-count", configuration.base_path, tenant=crate::clients::rest::apis::urlencode(p_tenant), workflow=crate::clients::rest::apis::urlencode(p_workflow));
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::WorkflowGetWorkersCount200Response`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::WorkflowGetWorkersCount200Response`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<WorkflowGetWorkersCountError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Get all workflows for a tenant
pub async fn workflow_list(configuration: &configuration::Configuration, tenant: &str, offset: Option<i32>, limit: Option<i32>, name: Option<&str>) -> Result<models::WorkflowList200Response, Error<WorkflowListError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_tenant = tenant;
    let p_offset = offset;
    let p_limit = limit;
    let p_name = name;

    let uri_str = format!("{}/api/v1/tenants/{tenant}/workflows", configuration.base_path, tenant=crate::clients::rest::apis::urlencode(p_tenant));
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = p_offset {
        req_builder = req_builder.query(&[("offset", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_limit {
        req_builder = req_builder.query(&[("limit", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_name {
        req_builder = req_builder.query(&[("name", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::WorkflowList200Response`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::WorkflowList200Response`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<WorkflowListError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Get a workflow run for a tenant
pub async fn workflow_run_get(configuration: &configuration::Configuration, tenant: &str, workflow_run: &str) -> Result<models::WorkflowRunCreate200Response, Error<WorkflowRunGetError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_tenant = tenant;
    let p_workflow_run = workflow_run;

    let uri_str = format!("{}/api/v1/tenants/{tenant}/workflow-runs/{workflow_run}", configuration.base_path, tenant=crate::clients::rest::apis::urlencode(p_tenant), workflow_run=crate::clients::rest::apis::urlencode(p_workflow_run));
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::WorkflowRunCreate200Response`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::WorkflowRunCreate200Response`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<WorkflowRunGetError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Get a summary of  workflow run metrics for a tenant
pub async fn workflow_run_get_metrics(configuration: &configuration::Configuration, tenant: &str, event_id: Option<&str>, workflow_id: Option<&str>, parent_workflow_run_id: Option<&str>, parent_step_run_id: Option<&str>, additional_metadata: Option<Vec<String>>, created_after: Option<String>, created_before: Option<String>) -> Result<models::WorkflowRunGetMetrics200Response, Error<WorkflowRunGetMetricsError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_tenant = tenant;
    let p_event_id = event_id;
    let p_workflow_id = workflow_id;
    let p_parent_workflow_run_id = parent_workflow_run_id;
    let p_parent_step_run_id = parent_step_run_id;
    let p_additional_metadata = additional_metadata;
    let p_created_after = created_after;
    let p_created_before = created_before;

    let uri_str = format!("{}/api/v1/tenants/{tenant}/workflows/runs/metrics", configuration.base_path, tenant=crate::clients::rest::apis::urlencode(p_tenant));
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = p_event_id {
        req_builder = req_builder.query(&[("eventId", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_workflow_id {
        req_builder = req_builder.query(&[("workflowId", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_parent_workflow_run_id {
        req_builder = req_builder.query(&[("parentWorkflowRunId", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_parent_step_run_id {
        req_builder = req_builder.query(&[("parentStepRunId", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_additional_metadata {
        req_builder = match "multi" {
            "multi" => req_builder.query(&param_value.into_iter().map(|p| ("additionalMetadata".to_owned(), p.to_string())).collect::<Vec<(std::string::String, std::string::String)>>()),
            _ => req_builder.query(&[("additionalMetadata", &param_value.into_iter().map(|p| p.to_string()).collect::<Vec<String>>().join(",").to_string())]),
        };
    }
    if let Some(ref param_value) = p_created_after {
        req_builder = req_builder.query(&[("createdAfter", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_created_before {
        req_builder = req_builder.query(&[("createdBefore", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::WorkflowRunGetMetrics200Response`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::WorkflowRunGetMetrics200Response`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<WorkflowRunGetMetricsError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Get a workflow run for a tenant
pub async fn workflow_run_get_shape(configuration: &configuration::Configuration, tenant: &str, workflow_run: &str) -> Result<models::WorkflowRunGetShape200Response, Error<WorkflowRunGetShapeError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_tenant = tenant;
    let p_workflow_run = workflow_run;

    let uri_str = format!("{}/api/v1/tenants/{tenant}/workflow-runs/{workflow_run}/shape", configuration.base_path, tenant=crate::clients::rest::apis::urlencode(p_tenant), workflow_run=crate::clients::rest::apis::urlencode(p_workflow_run));
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::WorkflowRunGetShape200Response`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::WorkflowRunGetShape200Response`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<WorkflowRunGetShapeError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Get all workflow runs for a tenant
pub async fn workflow_run_list(configuration: &configuration::Configuration, tenant: &str, offset: Option<i64>, limit: Option<i64>, event_id: Option<&str>, workflow_id: Option<&str>, parent_workflow_run_id: Option<&str>, parent_step_run_id: Option<&str>, statuses: Option<Vec<String>>, kinds: Option<Vec<String>>, additional_metadata: Option<Vec<String>>, created_after: Option<String>, created_before: Option<String>, finished_after: Option<String>, finished_before: Option<String>, order_by_field: Option<&str>, order_by_direction: Option<&str>) -> Result<models::WorkflowRunList200Response, Error<WorkflowRunListError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_tenant = tenant;
    let p_offset = offset;
    let p_limit = limit;
    let p_event_id = event_id;
    let p_workflow_id = workflow_id;
    let p_parent_workflow_run_id = parent_workflow_run_id;
    let p_parent_step_run_id = parent_step_run_id;
    let p_statuses = statuses;
    let p_kinds = kinds;
    let p_additional_metadata = additional_metadata;
    let p_created_after = created_after;
    let p_created_before = created_before;
    let p_finished_after = finished_after;
    let p_finished_before = finished_before;
    let p_order_by_field = order_by_field;
    let p_order_by_direction = order_by_direction;

    let uri_str = format!("{}/api/v1/tenants/{tenant}/workflows/runs", configuration.base_path, tenant=crate::clients::rest::apis::urlencode(p_tenant));
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = p_offset {
        req_builder = req_builder.query(&[("offset", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_limit {
        req_builder = req_builder.query(&[("limit", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_event_id {
        req_builder = req_builder.query(&[("eventId", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_workflow_id {
        req_builder = req_builder.query(&[("workflowId", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_parent_workflow_run_id {
        req_builder = req_builder.query(&[("parentWorkflowRunId", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_parent_step_run_id {
        req_builder = req_builder.query(&[("parentStepRunId", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_statuses {
        req_builder = match "multi" {
            "multi" => req_builder.query(&param_value.into_iter().map(|p| ("statuses".to_owned(), p.to_string())).collect::<Vec<(std::string::String, std::string::String)>>()),
            _ => req_builder.query(&[("statuses", &param_value.into_iter().map(|p| p.to_string()).collect::<Vec<String>>().join(",").to_string())]),
        };
    }
    if let Some(ref param_value) = p_kinds {
        req_builder = match "multi" {
            "multi" => req_builder.query(&param_value.into_iter().map(|p| ("kinds".to_owned(), p.to_string())).collect::<Vec<(std::string::String, std::string::String)>>()),
            _ => req_builder.query(&[("kinds", &param_value.into_iter().map(|p| p.to_string()).collect::<Vec<String>>().join(",").to_string())]),
        };
    }
    if let Some(ref param_value) = p_additional_metadata {
        req_builder = match "multi" {
            "multi" => req_builder.query(&param_value.into_iter().map(|p| ("additionalMetadata".to_owned(), p.to_string())).collect::<Vec<(std::string::String, std::string::String)>>()),
            _ => req_builder.query(&[("additionalMetadata", &param_value.into_iter().map(|p| p.to_string()).collect::<Vec<String>>().join(",").to_string())]),
        };
    }
    if let Some(ref param_value) = p_created_after {
        req_builder = req_builder.query(&[("createdAfter", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_created_before {
        req_builder = req_builder.query(&[("createdBefore", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_finished_after {
        req_builder = req_builder.query(&[("finishedAfter", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_finished_before {
        req_builder = req_builder.query(&[("finishedBefore", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_order_by_field {
        req_builder = req_builder.query(&[("orderByField", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_order_by_direction {
        req_builder = req_builder.query(&[("orderByDirection", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::WorkflowRunList200Response`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::WorkflowRunList200Response`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<WorkflowRunListError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Delete a scheduled workflow run for a tenant
pub async fn workflow_scheduled_delete(configuration: &configuration::Configuration, tenant: &str, scheduled_workflow_run: &str) -> Result<(), Error<WorkflowScheduledDeleteError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_tenant = tenant;
    let p_scheduled_workflow_run = scheduled_workflow_run;

    let uri_str = format!("{}/api/v1/tenants/{tenant}/workflows/scheduled/{scheduled_workflow_run}", configuration.base_path, tenant=crate::clients::rest::apis::urlencode(p_tenant), scheduled_workflow_run=crate::clients::rest::apis::urlencode(p_scheduled_workflow_run));
    let mut req_builder = configuration.client.request(reqwest::Method::DELETE, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        Ok(())
    } else {
        let content = resp.text().await?;
        let entity: Option<WorkflowScheduledDeleteError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Get a scheduled workflow run for a tenant
pub async fn workflow_scheduled_get(configuration: &configuration::Configuration, tenant: &str, scheduled_workflow_run: &str) -> Result<models::ScheduledWorkflowRunCreate200Response, Error<WorkflowScheduledGetError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_tenant = tenant;
    let p_scheduled_workflow_run = scheduled_workflow_run;

    let uri_str = format!("{}/api/v1/tenants/{tenant}/workflows/scheduled/{scheduled_workflow_run}", configuration.base_path, tenant=crate::clients::rest::apis::urlencode(p_tenant), scheduled_workflow_run=crate::clients::rest::apis::urlencode(p_scheduled_workflow_run));
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::ScheduledWorkflowRunCreate200Response`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::ScheduledWorkflowRunCreate200Response`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<WorkflowScheduledGetError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Get all scheduled workflow runs for a tenant
pub async fn workflow_scheduled_list(configuration: &configuration::Configuration, tenant: &str, offset: Option<i64>, limit: Option<i64>, order_by_field: Option<&str>, order_by_direction: Option<&str>, workflow_id: Option<&str>, parent_workflow_run_id: Option<&str>, parent_step_run_id: Option<&str>, additional_metadata: Option<Vec<String>>, statuses: Option<Vec<String>>) -> Result<models::WorkflowScheduledList200Response, Error<WorkflowScheduledListError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_tenant = tenant;
    let p_offset = offset;
    let p_limit = limit;
    let p_order_by_field = order_by_field;
    let p_order_by_direction = order_by_direction;
    let p_workflow_id = workflow_id;
    let p_parent_workflow_run_id = parent_workflow_run_id;
    let p_parent_step_run_id = parent_step_run_id;
    let p_additional_metadata = additional_metadata;
    let p_statuses = statuses;

    let uri_str = format!("{}/api/v1/tenants/{tenant}/workflows/scheduled", configuration.base_path, tenant=crate::clients::rest::apis::urlencode(p_tenant));
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = p_offset {
        req_builder = req_builder.query(&[("offset", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_limit {
        req_builder = req_builder.query(&[("limit", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_order_by_field {
        req_builder = req_builder.query(&[("orderByField", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_order_by_direction {
        req_builder = req_builder.query(&[("orderByDirection", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_workflow_id {
        req_builder = req_builder.query(&[("workflowId", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_parent_workflow_run_id {
        req_builder = req_builder.query(&[("parentWorkflowRunId", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_parent_step_run_id {
        req_builder = req_builder.query(&[("parentStepRunId", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_additional_metadata {
        req_builder = match "multi" {
            "multi" => req_builder.query(&param_value.into_iter().map(|p| ("additionalMetadata".to_owned(), p.to_string())).collect::<Vec<(std::string::String, std::string::String)>>()),
            _ => req_builder.query(&[("additionalMetadata", &param_value.into_iter().map(|p| p.to_string()).collect::<Vec<String>>().join(",").to_string())]),
        };
    }
    if let Some(ref param_value) = p_statuses {
        req_builder = match "multi" {
            "multi" => req_builder.query(&param_value.into_iter().map(|p| ("statuses".to_owned(), p.to_string())).collect::<Vec<(std::string::String, std::string::String)>>()),
            _ => req_builder.query(&[("statuses", &param_value.into_iter().map(|p| p.to_string()).collect::<Vec<String>>().join(",").to_string())]),
        };
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::WorkflowScheduledList200Response`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::WorkflowScheduledList200Response`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<WorkflowScheduledListError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Update a workflow for a tenant
pub async fn workflow_update(configuration: &configuration::Configuration, workflow: &str, workflow_update_request: models::WorkflowUpdateRequest) -> Result<models::WorkflowList200ResponseRowsInner, Error<WorkflowUpdateError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_workflow = workflow;
    let p_workflow_update_request = workflow_update_request;

    let uri_str = format!("{}/api/v1/workflows/{workflow}", configuration.base_path, workflow=crate::clients::rest::apis::urlencode(p_workflow));
    let mut req_builder = configuration.client.request(reqwest::Method::PATCH, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    req_builder = req_builder.json(&p_workflow_update_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::WorkflowList200ResponseRowsInner`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::WorkflowList200ResponseRowsInner`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<WorkflowUpdateError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Get a workflow version for a tenant
pub async fn workflow_version_get(configuration: &configuration::Configuration, workflow: &str, version: Option<&str>) -> Result<models::WorkflowVersionGet200Response, Error<WorkflowVersionGetError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_workflow = workflow;
    let p_version = version;

    let uri_str = format!("{}/api/v1/workflows/{workflow}/versions", configuration.base_path, workflow=crate::clients::rest::apis::urlencode(p_workflow));
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = p_version {
        req_builder = req_builder.query(&[("version", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::WorkflowVersionGet200Response`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::WorkflowVersionGet200Response`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<WorkflowVersionGetError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

